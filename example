
zig-out/bin/learn-os:     file format elf32-i386


Disassembly of section .text:

00100000 <multiboot>:
  100000:	02 b0 ad 1b 03 00 00 00 fb 4f 52 e4 cc cc cc cc     .........OR.....

00100010 <panic>:
    @call(.{ .stack = stack_bytes_slice }, kmain, .{}); 

    while (true) {}
}

pub fn panic(msg: []const u8, error_return_trace: ?*builtin.StackTrace) noreturn {
  100010:	55                   	push   %ebp
  100011:	89 e5                	mov    %esp,%ebp
  100013:	83 ec 20             	sub    $0x20,%esp
  100016:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  100019:	89 55 e8             	mov    %edx,-0x18(%ebp)
    @setCold(true);

    var term = Terminal.init();
  10001c:	8d 4d f4             	lea    -0xc(%ebp),%ecx
  10001f:	e8 6c 00 00 00       	call   100090 <Terminal.init>

    term.clear(ColourCode.init(.red, .red));
  100024:	8d 4d f0             	lea    -0x10(%ebp),%ecx
  100027:	ba 04 00 00 00       	mov    $0x4,%edx
  10002c:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  100033:	e8 78 00 00 00       	call   1000b0 <ColourCode.init>
  100038:	8a 45 f0             	mov    -0x10(%ebp),%al
  10003b:	88 45 ec             	mov    %al,-0x14(%ebp)
  10003e:	c6 45 ed 01          	movb   $0x1,-0x13(%ebp)
  100042:	8d 4d f4             	lea    -0xc(%ebp),%ecx
  100045:	8d 55 ec             	lea    -0x14(%ebp),%edx
  100048:	e8 83 00 00 00       	call   1000d0 <Terminal.clear>

    term.write_row('=');
  10004d:	8d 4d f4             	lea    -0xc(%ebp),%ecx
  100050:	ba 3d 00 00 00       	mov    $0x3d,%edx
  100055:	e8 a6 01 00 00       	call   100200 <Terminal.write_row>

    term.writeln("!!!KERNEL PANIC!!!");
  10005a:	8d 4d f4             	lea    -0xc(%ebp),%ecx
  10005d:	8d 15 a4 10 10 00    	lea    0x1010a4,%edx
  100063:	e8 c8 01 00 00       	call   100230 <Terminal.writeln>
  100068:	8b 55 e4             	mov    -0x1c(%ebp),%edx

    term.writeln(msg);
  10006b:	8d 4d f4             	lea    -0xc(%ebp),%ecx
  10006e:	e8 bd 01 00 00       	call   100230 <Terminal.writeln>

    term.write_row('=');
  100073:	8d 4d f4             	lea    -0xc(%ebp),%ecx
  100076:	ba 3d 00 00 00       	mov    $0x3d,%edx
  10007b:	e8 80 01 00 00       	call   100200 <Terminal.write_row>

    while (true) {}
  100080:	eb fe                	jmp    100080 <panic+0x70>
  100082:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  100089:	00 00 00 
  10008c:	0f 1f 40 00          	nopl   0x0(%eax)

00100090 <Terminal.init>:
    fn init() Terminal {
  100090:	55                   	push   %ebp
  100091:	89 e5                	mov    %esp,%ebp
  100093:	89 c8                	mov    %ecx,%eax
        return Terminal {};
  100095:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
  10009b:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
  1000a2:	8a 15 f8 10 10 00    	mov    0x1010f8,%dl
  1000a8:	88 51 08             	mov    %dl,0x8(%ecx)
  1000ab:	5d                   	pop    %ebp
  1000ac:	c3                   	ret    
  1000ad:	0f 1f 00             	nopl   (%eax)

001000b0 <ColourCode.init>:
    fn init(foreground: Colour, background: Colour) ColourCode {
  1000b0:	55                   	push   %ebp
  1000b1:	89 e5                	mov    %esp,%ebp
  1000b3:	50                   	push   %eax
  1000b4:	89 c8                	mov    %ecx,%eax
  1000b6:	8a 75 08             	mov    0x8(%ebp),%dh
  1000b9:	88 55 ff             	mov    %dl,-0x1(%ebp)
        return ColourCode { .colour = (@enumToInt(background) << 4) | @enumToInt(foreground) };
  1000bc:	8a 55 08             	mov    0x8(%ebp),%dl
  1000bf:	c0 e2 04             	shl    $0x4,%dl
  1000c2:	0a 55 ff             	or     -0x1(%ebp),%dl
  1000c5:	88 11                	mov    %dl,(%ecx)
  1000c7:	83 c4 04             	add    $0x4,%esp
  1000ca:	5d                   	pop    %ebp
  1000cb:	c3                   	ret    
  1000cc:	0f 1f 40 00          	nopl   0x0(%eax)

001000d0 <Terminal.clear>:
    fn clear(self: *Self, colour: ?ColourCode) void {
  1000d0:	55                   	push   %ebp
  1000d1:	89 e5                	mov    %esp,%ebp
  1000d3:	56                   	push   %esi
  1000d4:	83 ec 30             	sub    $0x30,%esp
  1000d7:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  1000da:	89 4d e8             	mov    %ecx,-0x18(%ebp)
        var y: usize = 0;
  1000dd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
        while (y < VGA_HEIGHT): (y += 1) {
  1000e4:	83 7d f8 19          	cmpl   $0x19,-0x8(%ebp)
  1000e8:	73 71                	jae    10015b <Terminal.clear+0x8b>
            var x: usize = 0;
  1000ea:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            while (x < VGA_WIDTH): (x += 1) {
  1000f1:	83 7d f4 50          	cmpl   $0x50,-0xc(%ebp)
  1000f5:	73 4d                	jae    100144 <Terminal.clear+0x74>
                const index = y * VGA_WIDTH + x;
  1000f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1000fa:	b9 50 00 00 00       	mov    $0x50,%ecx
  1000ff:	f7 e1                	mul    %ecx
  100101:	89 45 e0             	mov    %eax,-0x20(%ebp)
  100104:	0f 90 c0             	seto   %al
  100107:	70 6b                	jo     100174 <Terminal.clear+0xa4>
  100109:	eb 76                	jmp    100181 <Terminal.clear+0xb1>
  10010b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
                if (colour) |new_colour| {
  10010e:	8a 00                	mov    (%eax),%al
  100110:	88 45 ec             	mov    %al,-0x14(%ebp)
                    buffer[index].colour_code = new_colour;
  100113:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100116:	c1 e0 01             	shl    $0x1,%eax
  100119:	03 05 a4 11 10 00    	add    0x1011a4,%eax
  10011f:	83 c0 01             	add    $0x1,%eax
  100122:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  100125:	8a 09                	mov    (%ecx),%cl
  100127:	88 08                	mov    %cl,(%eax)
                if (colour) |new_colour| {
  100129:	eb 02                	jmp    10012d <Terminal.clear+0x5d>
  10012b:	eb 00                	jmp    10012d <Terminal.clear+0x5d>
            while (x < VGA_WIDTH): (x += 1) {
  10012d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100130:	83 c0 01             	add    $0x1,%eax
  100133:	89 45 dc             	mov    %eax,-0x24(%ebp)
  100136:	0f 92 c0             	setb   %al
  100139:	0f 82 91 00 00 00    	jb     1001d0 <Terminal.clear+0x100>
  10013f:	e9 99 00 00 00       	jmp    1001dd <Terminal.clear+0x10d>
        while (y < VGA_HEIGHT): (y += 1) {
  100144:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100147:	83 c0 01             	add    $0x1,%eax
  10014a:	89 45 d8             	mov    %eax,-0x28(%ebp)
  10014d:	0f 92 c0             	setb   %al
  100150:	0f 82 92 00 00 00    	jb     1001e8 <Terminal.clear+0x118>
  100156:	e9 9a 00 00 00       	jmp    1001f5 <Terminal.clear+0x125>
        self.row = 0;
  10015b:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10015e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        self.column = 0;
  100164:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100167:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    fn clear(self: *Self, colour: ?ColourCode) void {
  10016e:	83 c4 30             	add    $0x30,%esp
  100171:	5e                   	pop    %esi
  100172:	5d                   	pop    %ebp
  100173:	c3                   	ret    
                const index = y * VGA_WIDTH + x;
  100174:	8d 0d fc 10 10 00    	lea    0x1010fc,%ecx
  10017a:	31 d2                	xor    %edx,%edx
  10017c:	e8 8f fe ff ff       	call   100010 <panic>
  100181:	8b 45 e0             	mov    -0x20(%ebp),%eax
  100184:	03 45 f4             	add    -0xc(%ebp),%eax
  100187:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  10018a:	0f 92 c0             	setb   %al
  10018d:	72 02                	jb     100191 <Terminal.clear+0xc1>
  10018f:	eb 0d                	jmp    10019e <Terminal.clear+0xce>
  100191:	8d 0d fc 10 10 00    	lea    0x1010fc,%ecx
  100197:	31 d2                	xor    %edx,%edx
  100199:	e8 72 fe ff ff       	call   100010 <panic>
  10019e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  1001a1:	89 45 f0             	mov    %eax,-0x10(%ebp)
                self.putCharAt(' ', x, y);
  1001a4:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  1001a7:	8b 75 f4             	mov    -0xc(%ebp),%esi
  1001aa:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1001ad:	ba 20 00 00 00       	mov    $0x20,%edx
  1001b2:	89 34 24             	mov    %esi,(%esp)
  1001b5:	89 44 24 04          	mov    %eax,0x4(%esp)
  1001b9:	e8 32 03 00 00       	call   1004f0 <Terminal.putCharAt>
  1001be:	8b 45 e4             	mov    -0x1c(%ebp),%eax
                if (colour) |new_colour| {
  1001c1:	f6 40 01 01          	testb  $0x1,0x1(%eax)
  1001c5:	0f 85 40 ff ff ff    	jne    10010b <Terminal.clear+0x3b>
  1001cb:	e9 5b ff ff ff       	jmp    10012b <Terminal.clear+0x5b>
            while (x < VGA_WIDTH): (x += 1) {
  1001d0:	8d 0d fc 10 10 00    	lea    0x1010fc,%ecx
  1001d6:	31 d2                	xor    %edx,%edx
  1001d8:	e8 33 fe ff ff       	call   100010 <panic>
  1001dd:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1001e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1001e3:	e9 09 ff ff ff       	jmp    1000f1 <Terminal.clear+0x21>
        while (y < VGA_HEIGHT): (y += 1) {
  1001e8:	8d 0d fc 10 10 00    	lea    0x1010fc,%ecx
  1001ee:	31 d2                	xor    %edx,%edx
  1001f0:	e8 1b fe ff ff       	call   100010 <panic>
  1001f5:	8b 45 d8             	mov    -0x28(%ebp),%eax
  1001f8:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1001fb:	e9 e4 fe ff ff       	jmp    1000e4 <Terminal.clear+0x14>

00100200 <Terminal.write_row>:
    fn write_row(self: *Self, screen_char: u8) void {
  100200:	55                   	push   %ebp
  100201:	89 e5                	mov    %esp,%ebp
  100203:	83 ec 0c             	sub    $0xc,%esp
  100206:	88 d0                	mov    %dl,%al
  100208:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  10020b:	88 45 fb             	mov    %al,-0x5(%ebp)
        self.write_row_absolute(screen_char, self.row); 
  10020e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  100211:	8a 55 fb             	mov    -0x5(%ebp),%dl
  100214:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100217:	8b 00                	mov    (%eax),%eax
  100219:	0f b6 d2             	movzbl %dl,%edx
  10021c:	89 04 24             	mov    %eax,(%esp)
  10021f:	e8 9c 03 00 00       	call   1005c0 <Terminal.write_row_absolute>
    fn write_row(self: *Self, screen_char: u8) void {
  100224:	83 c4 0c             	add    $0xc,%esp
  100227:	5d                   	pop    %ebp
  100228:	c3                   	ret    
  100229:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

00100230 <Terminal.writeln>:
    fn writeln(self: *Self, msg: []const u8) void {
  100230:	55                   	push   %ebp
  100231:	89 e5                	mov    %esp,%ebp
  100233:	83 ec 18             	sub    $0x18,%esp
  100236:	89 55 ec             	mov    %edx,-0x14(%ebp)
  100239:	89 4d f4             	mov    %ecx,-0xc(%ebp)
        for (msg) |c| {
  10023c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  100243:	8b 42 04             	mov    0x4(%edx),%eax
  100246:	89 45 f0             	mov    %eax,-0x10(%ebp)
  100249:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10024c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10024f:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100252:	39 c8                	cmp    %ecx,%eax
  100254:	73 25                	jae    10027b <Terminal.writeln+0x4b>
  100256:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  100259:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10025c:	8b 00                	mov    (%eax),%eax
  10025e:	8a 04 08             	mov    (%eax,%ecx,1),%al
  100261:	88 45 fb             	mov    %al,-0x5(%ebp)
            self.putChar(c);
  100264:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  100267:	0f b6 55 fb          	movzbl -0x5(%ebp),%edx
  10026b:	e8 40 04 00 00       	call   1006b0 <Terminal.putChar>
  100270:	8b 45 e8             	mov    -0x18(%ebp),%eax
        for (msg) |c| {
  100273:	83 c0 01             	add    $0x1,%eax
  100276:	89 45 fc             	mov    %eax,-0x4(%ebp)
  100279:	eb ce                	jmp    100249 <Terminal.writeln+0x19>
        self.putChar('\n');
  10027b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10027e:	ba 0a 00 00 00       	mov    $0xa,%edx
  100283:	e8 28 04 00 00       	call   1006b0 <Terminal.putChar>
    fn writeln(self: *Self, msg: []const u8) void {
  100288:	83 c4 18             	add    $0x18,%esp
  10028b:	5d                   	pop    %ebp
  10028c:	c3                   	ret    
  10028d:	0f 1f 00             	nopl   (%eax)

00100290 <_start>:
    @call(.{ .stack = stack_bytes_slice }, kmain, .{}); 
  100290:	a1 ac 10 10 00       	mov    0x1010ac,%eax
  100295:	8b 0d b0 10 10 00    	mov    0x1010b0,%ecx
  10029b:	01 c8                	add    %ecx,%eax
  10029d:	89 c1                	mov    %eax,%ecx
  10029f:	83 e1 0f             	and    $0xf,%ecx
  1002a2:	29 c8                	sub    %ecx,%eax
  1002a4:	89 e1                	mov    %esp,%ecx
  1002a6:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  1002a9:	89 c4                	mov    %eax,%esp
  1002ab:	e8 10 00 00 00       	call   1002c0 <kmain>
  1002b0:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1002b3:	89 c4                	mov    %eax,%esp
    while (true) {}
  1002b5:	eb fe                	jmp    1002b5 <_start+0x25>
  1002b7:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  1002be:	00 00 

001002c0 <kmain>:
}

fn kmain() void {
  1002c0:	55                   	push   %ebp
  1002c1:	89 e5                	mov    %esp,%ebp
  1002c3:	81 ec a8 00 00 00    	sub    $0xa8,%esp
  1002c9:	c7 85 74 ff ff ff 00 	movl   $0x0,-0x8c(%ebp)
  1002d0:	00 00 00 
  1002d3:	8d 45 80             	lea    -0x80(%ebp),%eax
  1002d6:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
  1002dc:	c7 85 7c ff ff ff 20 	movl   $0x20,-0x84(%ebp)
  1002e3:	00 00 00 
    var term = Terminal.init();
  1002e6:	8d 8d 68 ff ff ff    	lea    -0x98(%ebp),%ecx
  1002ec:	e8 9f fd ff ff       	call   100090 <Terminal.init>

    const out = Terminal.writer{ .context = &term };
  1002f1:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
  1002f7:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)

    term.clear(null);
  1002fd:	8d 8d 68 ff ff ff    	lea    -0x98(%ebp),%ecx
  100303:	8d 15 04 11 10 00    	lea    0x101104,%edx
  100309:	e8 c2 fd ff ff       	call   1000d0 <Terminal.clear>

    out.writeByteNTimes(0, 5) catch |e| switch (e) {};
  10030e:	8d 8d 74 ff ff ff    	lea    -0x8c(%ebp),%ecx
  100314:	8d 95 64 ff ff ff    	lea    -0x9c(%ebp),%edx
  10031a:	31 c0                	xor    %eax,%eax
  10031c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  100323:	c7 44 24 04 05 00 00 	movl   $0x5,0x4(%esp)
  10032a:	00 
  10032b:	e8 50 04 00 00       	call   100780 <std.io.writer.Writer(*Terminal,NoError,Terminal.writer_write).writeByteNTimes>
  100330:	66 89 85 62 ff ff ff 	mov    %ax,-0x9e(%ebp)

    //out.writeAll("abc") catch |e| out.writeAll(e);

    while (true) {
        asm volatile ("hlt");
  100337:	f4                   	hlt    
    while (true) {
  100338:	eb fd                	jmp    100337 <kmain+0x77>
  10033a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00100340 <std.target.Feature.feature_set_fns(std.target.x86.Feature).featureSet>:
            };

            pub fn feature_set_fns(comptime F: type) type {
                return struct {
                    /// Populates only the feature bits specified.
                    pub fn featureSet(features: []const F) Set {
  100340:	55                   	push   %ebp
  100341:	89 e5                	mov    %esp,%ebp
  100343:	83 ec 4c             	sub    $0x4c,%esp
  100346:	89 55 cc             	mov    %edx,-0x34(%ebp)
  100349:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
  10034c:	89 4d c8             	mov    %ecx,-0x38(%ebp)
                        var x = Set.empty_workaround(); // TODO remove empty_workaround
  10034f:	8d 4d dc             	lea    -0x24(%ebp),%ecx
  100352:	e8 69 00 00 00       	call   1003c0 <std.target.Set.empty_workaround>
  100357:	8b 55 cc             	mov    -0x34(%ebp),%edx
                        for (features) |feature| {
  10035a:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  100361:	8b 42 04             	mov    0x4(%edx),%eax
  100364:	89 45 d0             	mov    %eax,-0x30(%ebp)
  100367:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  10036a:	8b 45 d8             	mov    -0x28(%ebp),%eax
  10036d:	89 45 c0             	mov    %eax,-0x40(%ebp)
  100370:	39 c8                	cmp    %ecx,%eax
  100372:	73 28                	jae    10039c <std.target.Feature.feature_set_fns(std.target.x86.Feature).featureSet+0x5c>
  100374:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  100377:	8b 45 cc             	mov    -0x34(%ebp),%eax
  10037a:	8b 00                	mov    (%eax),%eax
  10037c:	8a 04 08             	mov    (%eax,%ecx,1),%al
  10037f:	88 45 d7             	mov    %al,-0x29(%ebp)
                            x.addFeature(@enumToInt(feature));
  100382:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
  100386:	66 89 c2             	mov    %ax,%dx
  100389:	8d 4d dc             	lea    -0x24(%ebp),%ecx
  10038c:	e8 5f 00 00 00       	call   1003f0 <std.target.Set.addFeature>
  100391:	8b 45 c0             	mov    -0x40(%ebp),%eax
                        for (features) |feature| {
  100394:	83 c0 01             	add    $0x1,%eax
  100397:	89 45 d8             	mov    %eax,-0x28(%ebp)
  10039a:	eb cb                	jmp    100367 <std.target.Feature.feature_set_fns(std.target.x86.Feature).featureSet+0x27>
  10039c:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
                        }
                        return x;
  10039f:	8d 45 dc             	lea    -0x24(%ebp),%eax
  1003a2:	89 0c 24             	mov    %ecx,(%esp)
  1003a5:	89 44 24 04          	mov    %eax,0x4(%esp)
  1003a9:	c7 44 24 08 24 00 00 	movl   $0x24,0x8(%esp)
  1003b0:	00 
  1003b1:	e8 ba 0e 00 00       	call   101270 <memcpy>
  1003b6:	8b 45 c8             	mov    -0x38(%ebp),%eax
  1003b9:	83 c4 4c             	add    $0x4c,%esp
  1003bc:	5d                   	pop    %ebp
  1003bd:	c3                   	ret    
  1003be:	66 90                	xchg   %ax,%ax

001003c0 <std.target.Set.empty_workaround>:
                pub fn empty_workaround() Set {
  1003c0:	55                   	push   %ebp
  1003c1:	89 e5                	mov    %esp,%ebp
  1003c3:	83 ec 10             	sub    $0x10,%esp
  1003c6:	89 c8                	mov    %ecx,%eax
  1003c8:	89 45 fc             	mov    %eax,-0x4(%ebp)
                    return Set{ .ints = [1]usize{0} ** usize_count };
  1003cb:	8d 05 b4 10 10 00    	lea    0x1010b4,%eax
  1003d1:	89 0c 24             	mov    %ecx,(%esp)
  1003d4:	89 44 24 04          	mov    %eax,0x4(%esp)
  1003d8:	c7 44 24 08 24 00 00 	movl   $0x24,0x8(%esp)
  1003df:	00 
  1003e0:	e8 8b 0e 00 00       	call   101270 <memcpy>
  1003e5:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1003e8:	83 c4 10             	add    $0x10,%esp
  1003eb:	5d                   	pop    %ebp
  1003ec:	c3                   	ret    
  1003ed:	0f 1f 00             	nopl   (%eax)

001003f0 <std.target.Set.addFeature>:
                pub fn addFeature(set: *Set, arch_feature_index: Index) void {
  1003f0:	55                   	push   %ebp
  1003f1:	89 e5                	mov    %esp,%ebp
  1003f3:	56                   	push   %esi
  1003f4:	83 ec 18             	sub    $0x18,%esp
  1003f7:	89 c8                	mov    %ecx,%eax
  1003f9:	66 89 d1             	mov    %dx,%cx
  1003fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1003ff:	66 89 c8             	mov    %cx,%ax
  100402:	25 ff 01 00 00       	and    $0x1ff,%eax
  100407:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
                    const usize_index = arch_feature_index / @bitSizeOf(usize);
  10040b:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
  10040f:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  100413:	31 c0                	xor    %eax,%eax
  100415:	a8 01                	test   $0x1,%al
  100417:	75 02                	jne    10041b <std.target.Set.addFeature+0x2b>
  100419:	eb 0d                	jmp    100428 <std.target.Set.addFeature+0x38>
  10041b:	8d 0d d8 10 10 00    	lea    0x1010d8,%ecx
  100421:	31 d2                	xor    %edx,%edx
  100423:	e8 e8 fb ff ff       	call   100010 <panic>
  100428:	66 8b 4d f0          	mov    -0x10(%ebp),%cx
  10042c:	66 89 c8             	mov    %cx,%ax
  10042f:	c1 e8 05             	shr    $0x5,%eax
  100432:	83 e0 0f             	and    $0xf,%eax
  100435:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
                    const bit_index = @intCast(ShiftInt, arch_feature_index % @bitSizeOf(usize));
  100439:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
  10043d:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
  100441:	31 c0                	xor    %eax,%eax
  100443:	a8 01                	test   $0x1,%al
  100445:	75 11                	jne    100458 <std.target.Set.addFeature+0x68>
  100447:	66 8b 45 ee          	mov    -0x12(%ebp),%ax
  10044b:	24 1f                	and    $0x1f,%al
  10044d:	88 45 ed             	mov    %al,-0x13(%ebp)
  100450:	b0 01                	mov    $0x1,%al
  100452:	84 c0                	test   %al,%al
  100454:	75 0f                	jne    100465 <std.target.Set.addFeature+0x75>
  100456:	eb 29                	jmp    100481 <std.target.Set.addFeature+0x91>
  100458:	8d 0d e0 10 10 00    	lea    0x1010e0,%ecx
  10045e:	31 d2                	xor    %edx,%edx
  100460:	e8 ab fb ff ff       	call   100010 <panic>
  100465:	8a 45 ed             	mov    -0x13(%ebp),%al
  100468:	24 1f                	and    $0x1f,%al
  10046a:	88 45 f9             	mov    %al,-0x7(%ebp)
                    set.ints[usize_index] |= @as(usize, 1) << bit_index;
  10046d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100470:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  100473:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
  100477:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10047a:	83 f8 09             	cmp    $0x9,%eax
  10047d:	72 1c                	jb     10049b <std.target.Set.addFeature+0xab>
  10047f:	eb 0d                	jmp    10048e <std.target.Set.addFeature+0x9e>
                    const bit_index = @intCast(ShiftInt, arch_feature_index % @bitSizeOf(usize));
  100481:	8d 0d e8 10 10 00    	lea    0x1010e8,%ecx
  100487:	31 d2                	xor    %edx,%edx
  100489:	e8 82 fb ff ff       	call   100010 <panic>
                    set.ints[usize_index] |= @as(usize, 1) << bit_index;
  10048e:	8d 0d f0 10 10 00    	lea    0x1010f0,%ecx
  100494:	31 d2                	xor    %edx,%edx
  100496:	e8 75 fb ff ff       	call   100010 <panic>
  10049b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10049e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  1004a1:	8b 14 88             	mov    (%eax,%ecx,4),%edx
  1004a4:	0f b6 4d f9          	movzbl -0x7(%ebp),%ecx
  1004a8:	be 01 00 00 00       	mov    $0x1,%esi
  1004ad:	d3 e6                	shl    %cl,%esi
  1004af:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  1004b2:	09 f2                	or     %esi,%edx
  1004b4:	89 14 88             	mov    %edx,(%eax,%ecx,4)
                pub fn addFeature(set: *Set, arch_feature_index: Index) void {
  1004b7:	83 c4 18             	add    $0x18,%esp
  1004ba:	5e                   	pop    %esi
  1004bb:	5d                   	pop    %ebp
  1004bc:	c3                   	ret    
  1004bd:	0f 1f 00             	nopl   (%eax)

001004c0 <std.target.Arch.isWasm>:
                    .thumb, .thumbeb => true,
                    else => false,
                };
            }

            pub fn isWasm(arch: Arch) bool {
  1004c0:	55                   	push   %ebp
  1004c1:	89 e5                	mov    %esp,%ebp
  1004c3:	83 ec 02             	sub    $0x2,%esp
  1004c6:	88 c8                	mov    %cl,%al
  1004c8:	24 3f                	and    $0x3f,%al
  1004ca:	88 45 fe             	mov    %al,-0x2(%ebp)
                return switch (arch) {
  1004cd:	8a 45 fe             	mov    -0x2(%ebp),%al
  1004d0:	04 10                	add    $0x10,%al
  1004d2:	24 3f                	and    $0x3f,%al
  1004d4:	2c 02                	sub    $0x2,%al
  1004d6:	72 08                	jb     1004e0 <std.target.Arch.isWasm+0x20>
  1004d8:	eb 00                	jmp    1004da <std.target.Arch.isWasm+0x1a>
                    .wasm32, .wasm64 => true,
                    else => false,
  1004da:	c6 45 ff 00          	movb   $0x0,-0x1(%ebp)
                return switch (arch) {
  1004de:	eb 04                	jmp    1004e4 <std.target.Arch.isWasm+0x24>
                    .wasm32, .wasm64 => true,
  1004e0:	c6 45 ff 01          	movb   $0x1,-0x1(%ebp)
                return switch (arch) {
  1004e4:	8a 45 ff             	mov    -0x1(%ebp),%al
  1004e7:	83 c4 02             	add    $0x2,%esp
  1004ea:	5d                   	pop    %ebp
  1004eb:	c3                   	ret    
  1004ec:	0f 1f 40 00          	nopl   0x0(%eax)

001004f0 <Terminal.putCharAt>:
    fn putCharAt(self: *Self, screen_char: u8, x: usize, y: usize) void {
  1004f0:	55                   	push   %ebp
  1004f1:	89 e5                	mov    %esp,%ebp
  1004f3:	83 ec 1c             	sub    $0x1c,%esp
  1004f6:	88 d0                	mov    %dl,%al
  1004f8:	8b 55 0c             	mov    0xc(%ebp),%edx
  1004fb:	8b 55 08             	mov    0x8(%ebp),%edx
  1004fe:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  100501:	88 45 f7             	mov    %al,-0x9(%ebp)
        if (screen_char == '\n') {
  100504:	80 7d f7 0a          	cmpb   $0xa,-0x9(%ebp)
  100508:	75 15                	jne    10051f <Terminal.putCharAt+0x2f>
            self.row += 1;
  10050a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10050d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  100510:	8b 00                	mov    (%eax),%eax
  100512:	83 c0 01             	add    $0x1,%eax
  100515:	89 45 f0             	mov    %eax,-0x10(%ebp)
  100518:	0f 92 c0             	setb   %al
  10051b:	72 18                	jb     100535 <Terminal.putCharAt+0x45>
  10051d:	eb 23                	jmp    100542 <Terminal.putCharAt+0x52>
        if (screen_char == '\n') {
  10051f:	eb 00                	jmp    100521 <Terminal.putCharAt+0x31>
        const index = y * VGA_WIDTH + x;
  100521:	8b 45 0c             	mov    0xc(%ebp),%eax
  100524:	b9 50 00 00 00       	mov    $0x50,%ecx
  100529:	f7 e1                	mul    %ecx
  10052b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10052e:	0f 90 c0             	seto   %al
  100531:	70 26                	jo     100559 <Terminal.putCharAt+0x69>
  100533:	eb 31                	jmp    100566 <Terminal.putCharAt+0x76>
            self.row += 1;
  100535:	8d 0d fc 10 10 00    	lea    0x1010fc,%ecx
  10053b:	31 d2                	xor    %edx,%edx
  10053d:	e8 ce fa ff ff       	call   100010 <panic>
  100542:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100545:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  100548:	89 08                	mov    %ecx,(%eax)
            self.column = 0;
  10054a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10054d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
            return;
  100554:	83 c4 1c             	add    $0x1c,%esp
  100557:	5d                   	pop    %ebp
  100558:	c3                   	ret    
        const index = y * VGA_WIDTH + x;
  100559:	8d 0d fc 10 10 00    	lea    0x1010fc,%ecx
  10055f:	31 d2                	xor    %edx,%edx
  100561:	e8 aa fa ff ff       	call   100010 <panic>
  100566:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100569:	03 45 08             	add    0x8(%ebp),%eax
  10056c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10056f:	0f 92 c0             	setb   %al
  100572:	72 02                	jb     100576 <Terminal.putCharAt+0x86>
  100574:	eb 0d                	jmp    100583 <Terminal.putCharAt+0x93>
  100576:	8d 0d fc 10 10 00    	lea    0x1010fc,%ecx
  10057c:	31 d2                	xor    %edx,%edx
  10057e:	e8 8d fa ff ff       	call   100010 <panic>
  100583:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  100586:	89 45 fc             	mov    %eax,-0x4(%ebp)
        buffer[index].char = screen_char;
  100589:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  10058c:	a1 a4 11 10 00       	mov    0x1011a4,%eax
  100591:	8a 55 f7             	mov    -0x9(%ebp),%dl
  100594:	88 14 48             	mov    %dl,(%eax,%ecx,2)
        buffer[index].colour_code = self.current_colour;
  100597:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10059a:	c1 e0 01             	shl    $0x1,%eax
  10059d:	03 05 a4 11 10 00    	add    0x1011a4,%eax
  1005a3:	83 c0 01             	add    $0x1,%eax
  1005a6:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1005a9:	83 c1 08             	add    $0x8,%ecx
  1005ac:	8a 09                	mov    (%ecx),%cl
  1005ae:	88 08                	mov    %cl,(%eax)
    fn putCharAt(self: *Self, screen_char: u8, x: usize, y: usize) void {
  1005b0:	83 c4 1c             	add    $0x1c,%esp
  1005b3:	5d                   	pop    %ebp
  1005b4:	c3                   	ret    
  1005b5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  1005bc:	00 00 00 
  1005bf:	90                   	nop

001005c0 <Terminal.write_row_absolute>:
    fn write_row_absolute(self: *Self, screen_char: u8, row_write: usize) void {
  1005c0:	55                   	push   %ebp
  1005c1:	89 e5                	mov    %esp,%ebp
  1005c3:	56                   	push   %esi
  1005c4:	83 ec 2c             	sub    $0x2c,%esp
  1005c7:	88 d0                	mov    %dl,%al
  1005c9:	8b 55 08             	mov    0x8(%ebp),%edx
  1005cc:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  1005cf:	88 45 ef             	mov    %al,-0x11(%ebp)
        var i: usize = 0;
  1005d2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
        while (i < VGA_WIDTH) : (i += 1) {
  1005d9:	83 7d f8 50          	cmpl   $0x50,-0x8(%ebp)
  1005dd:	73 14                	jae    1005f3 <Terminal.write_row_absolute+0x33>
            const index = row_write * VGA_WIDTH + i;
  1005df:	8b 45 08             	mov    0x8(%ebp),%eax
  1005e2:	b9 50 00 00 00       	mov    $0x50,%ecx
  1005e7:	f7 e1                	mul    %ecx
  1005e9:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1005ec:	0f 90 c0             	seto   %al
  1005ef:	70 25                	jo     100616 <Terminal.write_row_absolute+0x56>
  1005f1:	eb 30                	jmp    100623 <Terminal.write_row_absolute+0x63>
        self.column = 0;
  1005f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1005f6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
        self.row = row_write + 1;
  1005fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100600:	89 45 e0             	mov    %eax,-0x20(%ebp)
  100603:	8b 45 08             	mov    0x8(%ebp),%eax
  100606:	83 c0 01             	add    $0x1,%eax
  100609:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10060c:	0f 92 c0             	setb   %al
  10060f:	72 78                	jb     100689 <Terminal.write_row_absolute+0xc9>
  100611:	e9 80 00 00 00       	jmp    100696 <Terminal.write_row_absolute+0xd6>
            const index = row_write * VGA_WIDTH + i;
  100616:	8d 0d fc 10 10 00    	lea    0x1010fc,%ecx
  10061c:	31 d2                	xor    %edx,%edx
  10061e:	e8 ed f9 ff ff       	call   100010 <panic>
  100623:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100626:	03 45 f8             	add    -0x8(%ebp),%eax
  100629:	89 45 dc             	mov    %eax,-0x24(%ebp)
  10062c:	0f 92 c0             	setb   %al
  10062f:	72 02                	jb     100633 <Terminal.write_row_absolute+0x73>
  100631:	eb 0d                	jmp    100640 <Terminal.write_row_absolute+0x80>
  100633:	8d 0d fc 10 10 00    	lea    0x1010fc,%ecx
  100639:	31 d2                	xor    %edx,%edx
  10063b:	e8 d0 f9 ff ff       	call   100010 <panic>
  100640:	8b 45 dc             	mov    -0x24(%ebp),%eax
  100643:	89 45 f4             	mov    %eax,-0xc(%ebp)
            self.putCharAt(screen_char, i, row_write);
  100646:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  100649:	8a 55 ef             	mov    -0x11(%ebp),%dl
  10064c:	8b 75 f8             	mov    -0x8(%ebp),%esi
  10064f:	8b 45 08             	mov    0x8(%ebp),%eax
  100652:	0f b6 d2             	movzbl %dl,%edx
  100655:	89 34 24             	mov    %esi,(%esp)
  100658:	89 44 24 04          	mov    %eax,0x4(%esp)
  10065c:	e8 8f fe ff ff       	call   1004f0 <Terminal.putCharAt>
        while (i < VGA_WIDTH) : (i += 1) {
  100661:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100664:	83 c0 01             	add    $0x1,%eax
  100667:	89 45 d8             	mov    %eax,-0x28(%ebp)
  10066a:	0f 92 c0             	setb   %al
  10066d:	72 02                	jb     100671 <Terminal.write_row_absolute+0xb1>
  10066f:	eb 0d                	jmp    10067e <Terminal.write_row_absolute+0xbe>
  100671:	8d 0d fc 10 10 00    	lea    0x1010fc,%ecx
  100677:	31 d2                	xor    %edx,%edx
  100679:	e8 92 f9 ff ff       	call   100010 <panic>
  10067e:	8b 45 d8             	mov    -0x28(%ebp),%eax
  100681:	89 45 f8             	mov    %eax,-0x8(%ebp)
  100684:	e9 50 ff ff ff       	jmp    1005d9 <Terminal.write_row_absolute+0x19>
        self.row = row_write + 1;
  100689:	8d 0d fc 10 10 00    	lea    0x1010fc,%ecx
  10068f:	31 d2                	xor    %edx,%edx
  100691:	e8 7a f9 ff ff       	call   100010 <panic>
  100696:	8b 45 e0             	mov    -0x20(%ebp),%eax
  100699:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  10069c:	89 08                	mov    %ecx,(%eax)
    fn write_row_absolute(self: *Self, screen_char: u8, row_write: usize) void {
  10069e:	83 c4 2c             	add    $0x2c,%esp
  1006a1:	5e                   	pop    %esi
  1006a2:	5d                   	pop    %ebp
  1006a3:	c3                   	ret    
  1006a4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  1006ab:	00 00 00 
  1006ae:	66 90                	xchg   %ax,%ax

001006b0 <Terminal.putChar>:
    fn putChar(self: *Self, screen_char: u8) void {
  1006b0:	55                   	push   %ebp
  1006b1:	89 e5                	mov    %esp,%ebp
  1006b3:	56                   	push   %esi
  1006b4:	83 ec 20             	sub    $0x20,%esp
  1006b7:	88 d0                	mov    %dl,%al
  1006b9:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1006bc:	88 45 f7             	mov    %al,-0x9(%ebp)
        self.putCharAt(screen_char, self.column, self.row);
  1006bf:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1006c2:	8a 55 f7             	mov    -0x9(%ebp),%dl
  1006c5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1006c8:	8b 70 04             	mov    0x4(%eax),%esi
  1006cb:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1006ce:	8b 00                	mov    (%eax),%eax
  1006d0:	0f b6 d2             	movzbl %dl,%edx
  1006d3:	89 34 24             	mov    %esi,(%esp)
  1006d6:	89 44 24 04          	mov    %eax,0x4(%esp)
  1006da:	e8 11 fe ff ff       	call   1004f0 <Terminal.putCharAt>
        if (screen_char != '\n') {
  1006df:	80 7d f7 0a          	cmpb   $0xa,-0x9(%ebp)
  1006e3:	74 1b                	je     100700 <Terminal.putChar+0x50>
            self.column += 1;
  1006e5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1006e8:	89 c1                	mov    %eax,%ecx
  1006ea:	83 c1 04             	add    $0x4,%ecx
  1006ed:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  1006f0:	8b 40 04             	mov    0x4(%eax),%eax
  1006f3:	83 c0 01             	add    $0x1,%eax
  1006f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1006f9:	0f 92 c0             	setb   %al
  1006fc:	72 48                	jb     100746 <Terminal.putChar+0x96>
  1006fe:	eb 53                	jmp    100753 <Terminal.putChar+0xa3>
        if (screen_char != '\n') {
  100700:	eb 00                	jmp    100702 <Terminal.putChar+0x52>
        if (self.column == VGA_WIDTH) {
  100702:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100705:	83 78 04 50          	cmpl   $0x50,0x4(%eax)
  100709:	75 1f                	jne    10072a <Terminal.putChar+0x7a>
            self.column = 0;
  10070b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10070e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
            self.row += 1;
  100715:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100718:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10071b:	8b 00                	mov    (%eax),%eax
  10071d:	83 c0 01             	add    $0x1,%eax
  100720:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100723:	0f 92 c0             	setb   %al
  100726:	72 35                	jb     10075d <Terminal.putChar+0xad>
  100728:	eb 40                	jmp    10076a <Terminal.putChar+0xba>
        if (self.column == VGA_WIDTH) {
  10072a:	eb 00                	jmp    10072c <Terminal.putChar+0x7c>
        if (self.row == VGA_HEIGHT) {
  10072c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10072f:	83 38 19             	cmpl   $0x19,(%eax)
  100732:	75 0a                	jne    10073e <Terminal.putChar+0x8e>
            self.scroll();
  100734:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100737:	e8 c4 01 00 00       	call   100900 <Terminal.scroll>
        if (self.row == VGA_HEIGHT) {
  10073c:	eb 02                	jmp    100740 <Terminal.putChar+0x90>
  10073e:	eb 00                	jmp    100740 <Terminal.putChar+0x90>
    fn putChar(self: *Self, screen_char: u8) void {
  100740:	83 c4 20             	add    $0x20,%esp
  100743:	5e                   	pop    %esi
  100744:	5d                   	pop    %ebp
  100745:	c3                   	ret    
            self.column += 1;
  100746:	8d 0d fc 10 10 00    	lea    0x1010fc,%ecx
  10074c:	31 d2                	xor    %edx,%edx
  10074e:	e8 bd f8 ff ff       	call   100010 <panic>
  100753:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100756:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  100759:	89 08                	mov    %ecx,(%eax)
        if (screen_char != '\n') {
  10075b:	eb a5                	jmp    100702 <Terminal.putChar+0x52>
            self.row += 1;
  10075d:	8d 0d fc 10 10 00    	lea    0x1010fc,%ecx
  100763:	31 d2                	xor    %edx,%edx
  100765:	e8 a6 f8 ff ff       	call   100010 <panic>
  10076a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10076d:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  100770:	89 08                	mov    %ecx,(%eax)
        if (self.column == VGA_WIDTH) {
  100772:	eb b8                	jmp    10072c <Terminal.putChar+0x7c>
  100774:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  10077b:	00 00 00 
  10077e:	66 90                	xchg   %ax,%ax

00100780 <std.io.writer.Writer(*Terminal,NoError,Terminal.writer_write).writeByteNTimes>:
        pub fn writeByte(self: Self, byte: u8) Error!void {
            const array = [1]u8{byte};
            return self.writeAll(&array);
        }

        pub fn writeByteNTimes(self: Self, byte: u8, n: usize) Error!void {
  100780:	55                   	push   %ebp
  100781:	89 e5                	mov    %esp,%ebp
  100783:	56                   	push   %esi
  100784:	81 ec 48 01 00 00    	sub    $0x148,%esp
  10078a:	89 95 c8 fe ff ff    	mov    %edx,-0x138(%ebp)
  100790:	89 8d cc fe ff ff    	mov    %ecx,-0x134(%ebp)
  100796:	8b 45 0c             	mov    0xc(%ebp),%eax
  100799:	8a 45 08             	mov    0x8(%ebp),%al
            var bytes: [256]u8 = undefined;
  10079c:	8d 85 fa fe ff ff    	lea    -0x106(%ebp),%eax
  1007a2:	89 04 24             	mov    %eax,(%esp)
  1007a5:	c7 44 24 04 aa 00 00 	movl   $0xaa,0x4(%esp)
  1007ac:	00 
  1007ad:	c7 44 24 08 00 01 00 	movl   $0x100,0x8(%esp)
  1007b4:	00 
  1007b5:	e8 f6 09 00 00       	call   1011b0 <memset>
            mem.set(u8, bytes[0..], byte);
  1007ba:	b0 01                	mov    $0x1,%al
  1007bc:	a8 01                	test   $0x1,%al
  1007be:	75 59                	jne    100819 <std.io.writer.Writer(*Terminal,NoError,Terminal.writer_write).writeByteNTimes+0x99>
  1007c0:	eb 4a                	jmp    10080c <std.io.writer.Writer(*Terminal,NoError,Terminal.writer_write).writeByteNTimes+0x8c>

            var remaining: usize = n;
            while (remaining > 0) {
  1007c2:	83 bd e4 fe ff ff 00 	cmpl   $0x0,-0x11c(%ebp)
  1007c9:	76 30                	jbe    1007fb <std.io.writer.Writer(*Terminal,NoError,Terminal.writer_write).writeByteNTimes+0x7b>
                const to_write = std.math.min(remaining, bytes.len);
  1007cb:	8b 8d e4 fe ff ff    	mov    -0x11c(%ebp),%ecx
  1007d1:	89 8d e0 fe ff ff    	mov    %ecx,-0x120(%ebp)
  1007d7:	ba 00 01 00 00       	mov    $0x100,%edx
  1007dc:	e8 2f 03 00 00       	call   100b10 <std.math.min>
  1007e1:	89 85 dc fe ff ff    	mov    %eax,-0x124(%ebp)
                try self.writeAll(bytes[0..to_write]);
  1007e7:	8b 8d dc fe ff ff    	mov    -0x124(%ebp),%ecx
  1007ed:	89 8d c4 fe ff ff    	mov    %ecx,-0x13c(%ebp)
  1007f3:	31 c0                	xor    %eax,%eax
  1007f5:	39 c8                	cmp    %ecx,%eax
  1007f7:	76 6e                	jbe    100867 <std.io.writer.Writer(*Terminal,NoError,Terminal.writer_write).writeByteNTimes+0xe7>
  1007f9:	eb 5f                	jmp    10085a <std.io.writer.Writer(*Terminal,NoError,Terminal.writer_write).writeByteNTimes+0xda>
        pub fn writeByteNTimes(self: Self, byte: u8, n: usize) Error!void {
  1007fb:	66 c7 45 fa 00 00    	movw   $0x0,-0x6(%ebp)
  100801:	31 c0                	xor    %eax,%eax
  100803:	81 c4 48 01 00 00    	add    $0x148,%esp
  100809:	5e                   	pop    %esi
  10080a:	5d                   	pop    %ebp
  10080b:	c3                   	ret    
            mem.set(u8, bytes[0..], byte);
  10080c:	8d 0d f0 10 10 00    	lea    0x1010f0,%ecx
  100812:	31 d2                	xor    %edx,%edx
  100814:	e8 f7 f7 ff ff       	call   100010 <panic>
  100819:	8d 8d fa fe ff ff    	lea    -0x106(%ebp),%ecx
  10081f:	89 8d f4 fe ff ff    	mov    %ecx,-0x10c(%ebp)
  100825:	8a 45 08             	mov    0x8(%ebp),%al
  100828:	88 85 f3 fe ff ff    	mov    %al,-0x10d(%ebp)
  10082e:	89 8d e8 fe ff ff    	mov    %ecx,-0x118(%ebp)
  100834:	c7 85 ec fe ff ff 00 	movl   $0x100,-0x114(%ebp)
  10083b:	01 00 00 
  10083e:	8d 8d e8 fe ff ff    	lea    -0x118(%ebp),%ecx
  100844:	0f b6 d0             	movzbl %al,%edx
  100847:	e8 74 02 00 00       	call   100ac0 <std.mem.set>
            var remaining: usize = n;
  10084c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10084f:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
            while (remaining > 0) {
  100855:	e9 68 ff ff ff       	jmp    1007c2 <std.io.writer.Writer(*Terminal,NoError,Terminal.writer_write).writeByteNTimes+0x42>
                try self.writeAll(bytes[0..to_write]);
  10085a:	8d 0d f0 10 10 00    	lea    0x1010f0,%ecx
  100860:	31 d2                	xor    %edx,%edx
  100862:	e8 a9 f7 ff ff       	call   100010 <panic>
  100867:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
  10086d:	3d 00 01 00 00       	cmp    $0x100,%eax
  100872:	76 0d                	jbe    100881 <std.io.writer.Writer(*Terminal,NoError,Terminal.writer_write).writeByteNTimes+0x101>
  100874:	8d 0d f0 10 10 00    	lea    0x1010f0,%ecx
  10087a:	31 d2                	xor    %edx,%edx
  10087c:	e8 8f f7 ff ff       	call   100010 <panic>
  100881:	8b 95 c8 fe ff ff    	mov    -0x138(%ebp),%edx
  100887:	8b 8d cc fe ff ff    	mov    -0x134(%ebp),%ecx
  10088d:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
  100893:	8d b5 fa fe ff ff    	lea    -0x106(%ebp),%esi
  100899:	83 e8 00             	sub    $0x0,%eax
  10089c:	89 b5 d4 fe ff ff    	mov    %esi,-0x12c(%ebp)
  1008a2:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%ebp)
  1008a8:	8d 85 d4 fe ff ff    	lea    -0x12c(%ebp),%eax
  1008ae:	89 04 24             	mov    %eax,(%esp)
  1008b1:	e8 8a 02 00 00       	call   100b40 <std.io.writer.Writer(*Terminal,NoError,Terminal.writer_write).writeAll>
  1008b6:	66 89 85 d2 fe ff ff 	mov    %ax,-0x12e(%ebp)
                remaining -= to_write;
  1008bd:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
  1008c3:	2b 85 dc fe ff ff    	sub    -0x124(%ebp),%eax
  1008c9:	89 85 c0 fe ff ff    	mov    %eax,-0x140(%ebp)
  1008cf:	0f 92 c0             	setb   %al
  1008d2:	72 02                	jb     1008d6 <std.io.writer.Writer(*Terminal,NoError,Terminal.writer_write).writeByteNTimes+0x156>
  1008d4:	eb 0d                	jmp    1008e3 <std.io.writer.Writer(*Terminal,NoError,Terminal.writer_write).writeByteNTimes+0x163>
  1008d6:	8d 0d fc 10 10 00    	lea    0x1010fc,%ecx
  1008dc:	31 d2                	xor    %edx,%edx
  1008de:	e8 2d f7 ff ff       	call   100010 <panic>
  1008e3:	8b 85 c0 fe ff ff    	mov    -0x140(%ebp),%eax
  1008e9:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
            while (remaining > 0) {
  1008ef:	e9 ce fe ff ff       	jmp    1007c2 <std.io.writer.Writer(*Terminal,NoError,Terminal.writer_write).writeByteNTimes+0x42>
  1008f4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  1008fb:	00 00 00 
  1008fe:	66 90                	xchg   %ax,%ax

00100900 <Terminal.scroll>:
    fn scroll(self: *Self) void {
  100900:	55                   	push   %ebp
  100901:	89 e5                	mov    %esp,%ebp
  100903:	56                   	push   %esi
  100904:	83 ec 38             	sub    $0x38,%esp
  100907:	89 4d ec             	mov    %ecx,-0x14(%ebp)
        var y: usize = 1;
  10090a:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
        while (y < VGA_HEIGHT) : (y += 1) {
  100911:	83 7d f8 19          	cmpl   $0x19,-0x8(%ebp)
  100915:	73 38                	jae    10094f <Terminal.scroll+0x4f>
            var x: usize = 0;
  100917:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            while (x < VGA_WIDTH) : (x += 1) {
  10091e:	83 7d f4 50          	cmpl   $0x50,-0xc(%ebp)
  100922:	73 14                	jae    100938 <Terminal.scroll+0x38>
                const index = y * VGA_WIDTH + x;
  100924:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100927:	b9 50 00 00 00       	mov    $0x50,%ecx
  10092c:	f7 e1                	mul    %ecx
  10092e:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100931:	0f 90 c0             	seto   %al
  100934:	70 33                	jo     100969 <Terminal.scroll+0x69>
  100936:	eb 3e                	jmp    100976 <Terminal.scroll+0x76>
        while (y < VGA_HEIGHT) : (y += 1) {
  100938:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10093b:	83 c0 01             	add    $0x1,%eax
  10093e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  100941:	0f 92 c0             	setb   %al
  100944:	0f 82 c9 00 00 00    	jb     100a13 <Terminal.scroll+0x113>
  10094a:	e9 d1 00 00 00       	jmp    100a20 <Terminal.scroll+0x120>
        self.write_row_absolute(' ', VGA_HEIGHT - 1);
  10094f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  100952:	ba 20 00 00 00       	mov    $0x20,%edx
  100957:	c7 04 24 18 00 00 00 	movl   $0x18,(%esp)
  10095e:	e8 5d fc ff ff       	call   1005c0 <Terminal.write_row_absolute>
    fn scroll(self: *Self) void {
  100963:	83 c4 38             	add    $0x38,%esp
  100966:	5e                   	pop    %esi
  100967:	5d                   	pop    %ebp
  100968:	c3                   	ret    
                const index = y * VGA_WIDTH + x;
  100969:	8d 0d fc 10 10 00    	lea    0x1010fc,%ecx
  10096f:	31 d2                	xor    %edx,%edx
  100971:	e8 9a f6 ff ff       	call   100010 <panic>
  100976:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100979:	03 45 f4             	add    -0xc(%ebp),%eax
  10097c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  10097f:	0f 92 c0             	setb   %al
  100982:	72 02                	jb     100986 <Terminal.scroll+0x86>
  100984:	eb 0d                	jmp    100993 <Terminal.scroll+0x93>
  100986:	8d 0d fc 10 10 00    	lea    0x1010fc,%ecx
  10098c:	31 d2                	xor    %edx,%edx
  10098e:	e8 7d f6 ff ff       	call   100010 <panic>
  100993:	8b 45 e0             	mov    -0x20(%ebp),%eax
  100996:	89 45 f0             	mov    %eax,-0x10(%ebp)
                self.putCharAt(buffer[index].char, x, y - 1);
  100999:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10099c:	89 45 d0             	mov    %eax,-0x30(%ebp)
  10099f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1009a2:	a1 a4 11 10 00       	mov    0x1011a4,%eax
  1009a7:	8a 04 48             	mov    (%eax,%ecx,2),%al
  1009aa:	88 45 d7             	mov    %al,-0x29(%ebp)
  1009ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1009b0:	89 45 d8             	mov    %eax,-0x28(%ebp)
  1009b3:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1009b6:	83 e8 01             	sub    $0x1,%eax
  1009b9:	89 45 dc             	mov    %eax,-0x24(%ebp)
  1009bc:	0f 92 c0             	setb   %al
  1009bf:	72 02                	jb     1009c3 <Terminal.scroll+0xc3>
  1009c1:	eb 0d                	jmp    1009d0 <Terminal.scroll+0xd0>
  1009c3:	8d 0d fc 10 10 00    	lea    0x1010fc,%ecx
  1009c9:	31 d2                	xor    %edx,%edx
  1009cb:	e8 40 f6 ff ff       	call   100010 <panic>
  1009d0:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1009d3:	8b 75 d8             	mov    -0x28(%ebp),%esi
  1009d6:	8a 55 d7             	mov    -0x29(%ebp),%dl
  1009d9:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  1009dc:	0f b6 d2             	movzbl %dl,%edx
  1009df:	89 34 24             	mov    %esi,(%esp)
  1009e2:	89 44 24 04          	mov    %eax,0x4(%esp)
  1009e6:	e8 05 fb ff ff       	call   1004f0 <Terminal.putCharAt>
            while (x < VGA_WIDTH) : (x += 1) {
  1009eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1009ee:	83 c0 01             	add    $0x1,%eax
  1009f1:	89 45 cc             	mov    %eax,-0x34(%ebp)
  1009f4:	0f 92 c0             	setb   %al
  1009f7:	72 02                	jb     1009fb <Terminal.scroll+0xfb>
  1009f9:	eb 0d                	jmp    100a08 <Terminal.scroll+0x108>
  1009fb:	8d 0d fc 10 10 00    	lea    0x1010fc,%ecx
  100a01:	31 d2                	xor    %edx,%edx
  100a03:	e8 08 f6 ff ff       	call   100010 <panic>
  100a08:	8b 45 cc             	mov    -0x34(%ebp),%eax
  100a0b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100a0e:	e9 0b ff ff ff       	jmp    10091e <Terminal.scroll+0x1e>
        while (y < VGA_HEIGHT) : (y += 1) {
  100a13:	8d 0d fc 10 10 00    	lea    0x1010fc,%ecx
  100a19:	31 d2                	xor    %edx,%edx
  100a1b:	e8 f0 f5 ff ff       	call   100010 <panic>
  100a20:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  100a23:	89 45 f8             	mov    %eax,-0x8(%ebp)
  100a26:	e9 e6 fe ff ff       	jmp    100911 <Terminal.scroll+0x11>
  100a2b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00100a30 <Terminal.writer_write>:
    fn writer_write(self: *Self, msg: []const u8) NoError!usize {
  100a30:	55                   	push   %ebp
  100a31:	89 e5                	mov    %esp,%ebp
  100a33:	83 ec 0c             	sub    $0xc,%esp
  100a36:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  100a39:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  100a3c:	8b 55 0c             	mov    0xc(%ebp),%edx
  100a3f:	89 55 f4             	mov    %edx,-0xc(%ebp)
  100a42:	8b 45 08             	mov    0x8(%ebp),%eax
        self.write(msg);
  100a45:	8b 4d 08             	mov    0x8(%ebp),%ecx
  100a48:	e8 23 00 00 00       	call   100a70 <Terminal.write>
  100a4d:	8b 55 f4             	mov    -0xc(%ebp),%edx
  100a50:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100a53:	8b 45 fc             	mov    -0x4(%ebp),%eax
        return msg.len;
  100a56:	8b 52 04             	mov    0x4(%edx),%edx
  100a59:	66 c7 41 04 00 00    	movw   $0x0,0x4(%ecx)
  100a5f:	89 11                	mov    %edx,(%ecx)
  100a61:	83 c4 0c             	add    $0xc,%esp
  100a64:	5d                   	pop    %ebp
  100a65:	c3                   	ret    
  100a66:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  100a6d:	00 00 00 

00100a70 <Terminal.write>:
    fn write(self: *Self, msg: []const u8) void {
  100a70:	55                   	push   %ebp
  100a71:	89 e5                	mov    %esp,%ebp
  100a73:	83 ec 18             	sub    $0x18,%esp
  100a76:	89 55 ec             	mov    %edx,-0x14(%ebp)
  100a79:	89 4d f4             	mov    %ecx,-0xc(%ebp)
        for (msg) |c| {
  100a7c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  100a83:	8b 42 04             	mov    0x4(%edx),%eax
  100a86:	89 45 f0             	mov    %eax,-0x10(%ebp)
  100a89:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  100a8c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100a8f:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100a92:	39 c8                	cmp    %ecx,%eax
  100a94:	73 25                	jae    100abb <Terminal.write+0x4b>
  100a96:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  100a99:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100a9c:	8b 00                	mov    (%eax),%eax
  100a9e:	8a 04 08             	mov    (%eax,%ecx,1),%al
  100aa1:	88 45 fb             	mov    %al,-0x5(%ebp)
            self.putChar(c);
  100aa4:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  100aa7:	0f b6 55 fb          	movzbl -0x5(%ebp),%edx
  100aab:	e8 00 fc ff ff       	call   1006b0 <Terminal.putChar>
  100ab0:	8b 45 e8             	mov    -0x18(%ebp),%eax
        for (msg) |c| {
  100ab3:	83 c0 01             	add    $0x1,%eax
  100ab6:	89 45 fc             	mov    %eax,-0x4(%ebp)
  100ab9:	eb ce                	jmp    100a89 <Terminal.write+0x19>
    fn write(self: *Self, msg: []const u8) void {
  100abb:	83 c4 18             	add    $0x18,%esp
  100abe:	5d                   	pop    %ebp
  100abf:	c3                   	ret    

00100ac0 <std.mem.set>:
        dest[i] = source[i];
    }
}

/// Sets all elements of `dest` to `value`.
pub fn set(comptime T: type, dest: []T, value: T) void {
  100ac0:	55                   	push   %ebp
  100ac1:	89 e5                	mov    %esp,%ebp
  100ac3:	83 ec 18             	sub    $0x18,%esp
  100ac6:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  100ac9:	88 d0                	mov    %dl,%al
  100acb:	88 45 f7             	mov    %al,-0x9(%ebp)
    for (dest) |*d|
  100ace:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  100ad5:	8b 41 04             	mov    0x4(%ecx),%eax
  100ad8:	89 45 f0             	mov    %eax,-0x10(%ebp)
  100adb:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  100ade:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100ae1:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100ae4:	39 c8                	cmp    %ecx,%eax
  100ae6:	73 1d                	jae    100b05 <std.mem.set+0x45>
  100ae8:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100aeb:	8b 55 ec             	mov    -0x14(%ebp),%edx
  100aee:	89 c1                	mov    %eax,%ecx
  100af0:	03 0a                	add    (%edx),%ecx
  100af2:	89 4d f8             	mov    %ecx,-0x8(%ebp)
        d.* = value;
  100af5:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100af8:	8a 55 f7             	mov    -0x9(%ebp),%dl
  100afb:	88 11                	mov    %dl,(%ecx)
    for (dest) |*d|
  100afd:	83 c0 01             	add    $0x1,%eax
  100b00:	89 45 fc             	mov    %eax,-0x4(%ebp)
  100b03:	eb d6                	jmp    100adb <std.mem.set+0x1b>
pub fn set(comptime T: type, dest: []T, value: T) void {
  100b05:	83 c4 18             	add    $0x18,%esp
  100b08:	5d                   	pop    %ebp
  100b09:	c3                   	ret    
  100b0a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00100b10 <std.math.min>:
    return @TypeOf(@as(A, 0) + @as(B, 0));
}

/// Returns the smaller number. When one of the parameter's type's full range fits in the other,
/// the return type is the smaller type.
pub fn min(x: anytype, y: anytype) Min(@TypeOf(x), @TypeOf(y)) {
  100b10:	55                   	push   %ebp
  100b11:	89 e5                	mov    %esp,%ebp
  100b13:	83 ec 0c             	sub    $0xc,%esp
  100b16:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  100b19:	89 55 f4             	mov    %edx,-0xc(%ebp)
    const Result = Min(@TypeOf(x), @TypeOf(y));
    if (x < y) {
  100b1c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100b1f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  100b22:	73 0e                	jae    100b32 <std.math.min+0x22>
        // TODO Zig should allow this as an implicit cast because x is immutable and in this
        // scope it is known to fit in the return type.
        switch (@typeInfo(Result)) {
            .Int => return @intCast(Result, x),
  100b24:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100b27:	89 45 fc             	mov    %eax,-0x4(%ebp)
  100b2a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100b2d:	83 c4 0c             	add    $0xc,%esp
  100b30:	5d                   	pop    %ebp
  100b31:	c3                   	ret    
        }
    } else {
        // TODO Zig should allow this as an implicit cast because y is immutable and in this
        // scope it is known to fit in the return type.
        switch (@typeInfo(Result)) {
            .Int => return @intCast(Result, y),
  100b32:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100b35:	89 45 fc             	mov    %eax,-0x4(%ebp)
  100b38:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100b3b:	83 c4 0c             	add    $0xc,%esp
  100b3e:	5d                   	pop    %ebp
  100b3f:	c3                   	ret    

00100b40 <std.io.writer.Writer(*Terminal,NoError,Terminal.writer_write).writeAll>:
        pub fn writeAll(self: Self, bytes: []const u8) Error!void {
  100b40:	55                   	push   %ebp
  100b41:	89 e5                	mov    %esp,%ebp
  100b43:	53                   	push   %ebx
  100b44:	57                   	push   %edi
  100b45:	56                   	push   %esi
  100b46:	83 ec 3c             	sub    $0x3c,%esp
  100b49:	89 55 d0             	mov    %edx,-0x30(%ebp)
  100b4c:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  100b4f:	8b 45 08             	mov    0x8(%ebp),%eax
  100b52:	89 45 d8             	mov    %eax,-0x28(%ebp)
            var index: usize = 0;
  100b55:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  100b5c:	8b 4d d8             	mov    -0x28(%ebp),%ecx
            while (index != bytes.len) {
  100b5f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100b62:	3b 41 04             	cmp    0x4(%ecx),%eax
  100b65:	74 1b                	je     100b82 <std.io.writer.Writer(*Terminal,NoError,Terminal.writer_write).writeAll+0x42>
  100b67:	8b 4d d8             	mov    -0x28(%ebp),%ecx
                index += try self.write(bytes[index..]);
  100b6a:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100b6d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  100b70:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100b73:	89 45 c8             	mov    %eax,-0x38(%ebp)
  100b76:	8b 49 04             	mov    0x4(%ecx),%ecx
  100b79:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  100b7c:	39 c8                	cmp    %ecx,%eax
  100b7e:	76 1f                	jbe    100b9f <std.io.writer.Writer(*Terminal,NoError,Terminal.writer_write).writeAll+0x5f>
  100b80:	eb 10                	jmp    100b92 <std.io.writer.Writer(*Terminal,NoError,Terminal.writer_write).writeAll+0x52>
        pub fn writeAll(self: Self, bytes: []const u8) Error!void {
  100b82:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
  100b88:	31 c0                	xor    %eax,%eax
  100b8a:	83 c4 3c             	add    $0x3c,%esp
  100b8d:	5e                   	pop    %esi
  100b8e:	5f                   	pop    %edi
  100b8f:	5b                   	pop    %ebx
  100b90:	5d                   	pop    %ebp
  100b91:	c3                   	ret    
                index += try self.write(bytes[index..]);
  100b92:	8d 0d f0 10 10 00    	lea    0x1010f0,%ecx
  100b98:	31 d2                	xor    %edx,%edx
  100b9a:	e8 71 f4 ff ff       	call   100010 <panic>
  100b9f:	eb 0d                	jmp    100bae <std.io.writer.Writer(*Terminal,NoError,Terminal.writer_write).writeAll+0x6e>
  100ba1:	8d 0d f0 10 10 00    	lea    0x1010f0,%ecx
  100ba7:	31 d2                	xor    %edx,%edx
  100ba9:	e8 62 f4 ff ff       	call   100010 <panic>
  100bae:	8b 75 d0             	mov    -0x30(%ebp),%esi
  100bb1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  100bb4:	8b 7d c8             	mov    -0x38(%ebp),%edi
  100bb7:	8b 45 cc             	mov    -0x34(%ebp),%eax
  100bba:	8b 5d d8             	mov    -0x28(%ebp),%ebx
  100bbd:	89 f9                	mov    %edi,%ecx
  100bbf:	03 0b                	add    (%ebx),%ecx
  100bc1:	29 f8                	sub    %edi,%eax
  100bc3:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  100bc6:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100bc9:	8d 4d dc             	lea    -0x24(%ebp),%ecx
  100bcc:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  100bcf:	89 34 24             	mov    %esi,(%esp)
  100bd2:	89 44 24 04          	mov    %eax,0x4(%esp)
  100bd6:	e8 35 00 00 00       	call   100c10 <std.io.writer.Writer(*Terminal,NoError,Terminal.writer_write).write>
  100bdb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  100bde:	03 45 dc             	add    -0x24(%ebp),%eax
  100be1:	89 45 c0             	mov    %eax,-0x40(%ebp)
  100be4:	0f 92 c0             	setb   %al
  100be7:	72 02                	jb     100beb <std.io.writer.Writer(*Terminal,NoError,Terminal.writer_write).writeAll+0xab>
  100be9:	eb 0d                	jmp    100bf8 <std.io.writer.Writer(*Terminal,NoError,Terminal.writer_write).writeAll+0xb8>
  100beb:	8d 0d fc 10 10 00    	lea    0x1010fc,%ecx
  100bf1:	31 d2                	xor    %edx,%edx
  100bf3:	e8 18 f4 ff ff       	call   100010 <panic>
  100bf8:	8b 45 c0             	mov    -0x40(%ebp),%eax
  100bfb:	89 45 ec             	mov    %eax,-0x14(%ebp)
            while (index != bytes.len) {
  100bfe:	e9 59 ff ff ff       	jmp    100b5c <std.io.writer.Writer(*Terminal,NoError,Terminal.writer_write).writeAll+0x1c>
  100c03:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  100c0a:	00 00 00 
  100c0d:	0f 1f 00             	nopl   (%eax)

00100c10 <std.io.writer.Writer(*Terminal,NoError,Terminal.writer_write).write>:
        pub fn write(self: Self, bytes: []const u8) Error!usize {
  100c10:	55                   	push   %ebp
  100c11:	89 e5                	mov    %esp,%ebp
  100c13:	56                   	push   %esi
  100c14:	83 ec 14             	sub    $0x14,%esp
  100c17:	89 55 f0             	mov    %edx,-0x10(%ebp)
  100c1a:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  100c1d:	89 c8                	mov    %ecx,%eax
  100c1f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100c22:	8b 45 0c             	mov    0xc(%ebp),%eax
  100c25:	8b 75 08             	mov    0x8(%ebp),%esi
            return writeFn(self.context, bytes);
  100c28:	8b 36                	mov    (%esi),%esi
  100c2a:	89 34 24             	mov    %esi,(%esp)
  100c2d:	89 44 24 04          	mov    %eax,0x4(%esp)
  100c31:	e8 fa fd ff ff       	call   100a30 <Terminal.writer_write>
  100c36:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100c39:	66 83 79 04 00       	cmpw   $0x0,0x4(%ecx)
  100c3e:	74 0a                	je     100c4a <std.io.writer.Writer(*Terminal,NoError,Terminal.writer_write).write+0x3a>
  100c40:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  100c43:	e8 18 00 00 00       	call   100c60 <__zig_return_error>
  100c48:	eb 02                	jmp    100c4c <std.io.writer.Writer(*Terminal,NoError,Terminal.writer_write).write+0x3c>
  100c4a:	eb 00                	jmp    100c4c <std.io.writer.Writer(*Terminal,NoError,Terminal.writer_write).write+0x3c>
  100c4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100c4f:	83 c4 14             	add    $0x14,%esp
  100c52:	5e                   	pop    %esi
  100c53:	5d                   	pop    %ebp
  100c54:	c3                   	ret    
  100c55:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  100c5c:	00 00 00 
  100c5f:	90                   	nop

00100c60 <__zig_return_error>:
  100c60:	55                   	push   %ebp
  100c61:	89 e5                	mov    %esp,%ebp
  100c63:	57                   	push   %edi
  100c64:	56                   	push   %esi
  100c65:	83 ec 08             	sub    $0x8,%esp
  100c68:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  100c6b:	8b 45 04             	mov    0x4(%ebp),%eax
  100c6e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100c71:	83 f9 00             	cmp    $0x0,%ecx
  100c74:	75 07                	jne    100c7d <__zig_return_error+0x1d>
  100c76:	83 c4 08             	add    $0x8,%esp
  100c79:	5e                   	pop    %esi
  100c7a:	5f                   	pop    %edi
  100c7b:	5d                   	pop    %ebp
  100c7c:	c3                   	ret    
  100c7d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100c80:	8b 7d f4             	mov    -0xc(%ebp),%edi
  100c83:	8b 50 08             	mov    0x8(%eax),%edx
  100c86:	8b 08                	mov    (%eax),%ecx
  100c88:	83 ea 01             	sub    $0x1,%edx
  100c8b:	89 ce                	mov    %ecx,%esi
  100c8d:	21 d6                	and    %edx,%esi
  100c8f:	8b 50 04             	mov    0x4(%eax),%edx
  100c92:	89 3c b2             	mov    %edi,(%edx,%esi,4)
  100c95:	83 c1 01             	add    $0x1,%ecx
  100c98:	89 08                	mov    %ecx,(%eax)
  100c9a:	83 c4 08             	add    $0x8,%esp
  100c9d:	5e                   	pop    %esi
  100c9e:	5f                   	pop    %edi
  100c9f:	5d                   	pop    %ebp
  100ca0:	c3                   	ret    

Disassembly of section .text.memset:

001011b0 <memset>:
  1011b0:	55                   	push   %ebp
  1011b1:	53                   	push   %ebx
  1011b2:	57                   	push   %edi
  1011b3:	56                   	push   %esi
  1011b4:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  1011b8:	8b 44 24 14          	mov    0x14(%esp),%eax
  1011bc:	85 c9                	test   %ecx,%ecx
  1011be:	0f 84 a2 00 00 00    	je     101266 <memset+0xb6>
  1011c4:	8a 54 24 18          	mov    0x18(%esp),%dl
  1011c8:	31 f6                	xor    %esi,%esi
  1011ca:	83 f9 04             	cmp    $0x4,%ecx
  1011cd:	0f 82 7d 00 00 00    	jb     101250 <memset+0xa0>
  1011d3:	31 f6                	xor    %esi,%esi
  1011d5:	83 f9 20             	cmp    $0x20,%ecx
  1011d8:	0f b6 fa             	movzbl %dl,%edi
  1011db:	72 3d                	jb     10121a <memset+0x6a>
  1011dd:	66 0f 6e c7          	movd   %edi,%xmm0
  1011e1:	89 ce                	mov    %ecx,%esi
  1011e3:	8d 58 10             	lea    0x10(%eax),%ebx
  1011e6:	66 0f 60 c0          	punpcklbw %xmm0,%xmm0
  1011ea:	83 e6 e0             	and    $0xffffffe0,%esi
  1011ed:	f2 0f 70 c0 00       	pshuflw $0x0,%xmm0,%xmm0
  1011f2:	89 f5                	mov    %esi,%ebp
  1011f4:	66 0f 70 c0 00       	pshufd $0x0,%xmm0,%xmm0
  1011f9:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)
  101200:	f3 0f 7f 43 f0       	movdqu %xmm0,-0x10(%ebx)
  101205:	f3 0f 7f 03          	movdqu %xmm0,(%ebx)
  101209:	83 c3 20             	add    $0x20,%ebx
  10120c:	83 c5 e0             	add    $0xffffffe0,%ebp
  10120f:	75 ef                	jne    101200 <memset+0x50>
  101211:	39 ce                	cmp    %ecx,%esi
  101213:	74 51                	je     101266 <memset+0xb6>
  101215:	f6 c1 1c             	test   $0x1c,%cl
  101218:	74 36                	je     101250 <memset+0xa0>
  10121a:	66 0f 6e c7          	movd   %edi,%xmm0
  10121e:	89 f3                	mov    %esi,%ebx
  101220:	89 ce                	mov    %ecx,%esi
  101222:	66 0f 60 c0          	punpcklbw %xmm0,%xmm0
  101226:	83 e6 fc             	and    $0xfffffffc,%esi
  101229:	8d 3c 18             	lea    (%eax,%ebx,1),%edi
  10122c:	f2 0f 70 c0 00       	pshuflw $0x0,%xmm0,%xmm0
  101231:	29 f3                	sub    %esi,%ebx
  101233:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  10123a:	00 00 00 
  10123d:	0f 1f 00             	nopl   (%eax)
  101240:	66 0f 7e 07          	movd   %xmm0,(%edi)
  101244:	83 c7 04             	add    $0x4,%edi
  101247:	83 c3 04             	add    $0x4,%ebx
  10124a:	75 f4                	jne    101240 <memset+0x90>
  10124c:	39 ce                	cmp    %ecx,%esi
  10124e:	74 16                	je     101266 <memset+0xb6>
  101250:	29 f1                	sub    %esi,%ecx
  101252:	01 c6                	add    %eax,%esi
  101254:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  10125b:	00 00 00 
  10125e:	66 90                	xchg   %ax,%ax
  101260:	88 16                	mov    %dl,(%esi)
  101262:	46                   	inc    %esi
  101263:	49                   	dec    %ecx
  101264:	75 fa                	jne    101260 <memset+0xb0>
  101266:	5e                   	pop    %esi
  101267:	5f                   	pop    %edi
  101268:	5b                   	pop    %ebx
  101269:	5d                   	pop    %ebp
  10126a:	c3                   	ret    

Disassembly of section .text.memcpy:

00101270 <memcpy>:
  101270:	53                   	push   %ebx
  101271:	57                   	push   %edi
  101272:	56                   	push   %esi
  101273:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  101277:	8b 44 24 10          	mov    0x10(%esp),%eax
  10127b:	85 c9                	test   %ecx,%ecx
  10127d:	74 7d                	je     1012fc <memcpy+0x8c>
  10127f:	8b 54 24 14          	mov    0x14(%esp),%edx
  101283:	31 f6                	xor    %esi,%esi
  101285:	83 f9 08             	cmp    $0x8,%ecx
  101288:	72 66                	jb     1012f0 <memcpy+0x80>
  10128a:	31 f6                	xor    %esi,%esi
  10128c:	83 f9 20             	cmp    $0x20,%ecx
  10128f:	72 31                	jb     1012c2 <memcpy+0x52>
  101291:	89 ce                	mov    %ecx,%esi
  101293:	31 ff                	xor    %edi,%edi
  101295:	83 e6 e0             	and    $0xffffffe0,%esi
  101298:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
  10129f:	00 
  1012a0:	0f 10 04 3a          	movups (%edx,%edi,1),%xmm0
  1012a4:	0f 10 4c 3a 10       	movups 0x10(%edx,%edi,1),%xmm1
  1012a9:	0f 11 04 38          	movups %xmm0,(%eax,%edi,1)
  1012ad:	0f 11 4c 38 10       	movups %xmm1,0x10(%eax,%edi,1)
  1012b2:	83 c7 20             	add    $0x20,%edi
  1012b5:	39 fe                	cmp    %edi,%esi
  1012b7:	75 e7                	jne    1012a0 <memcpy+0x30>
  1012b9:	39 ce                	cmp    %ecx,%esi
  1012bb:	74 3f                	je     1012fc <memcpy+0x8c>
  1012bd:	f6 c1 18             	test   $0x18,%cl
  1012c0:	74 2e                	je     1012f0 <memcpy+0x80>
  1012c2:	89 f7                	mov    %esi,%edi
  1012c4:	89 ce                	mov    %ecx,%esi
  1012c6:	83 e6 f8             	and    $0xfffffff8,%esi
  1012c9:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)
  1012d0:	f2 0f 10 04 3a       	movsd  (%edx,%edi,1),%xmm0
  1012d5:	f2 0f 11 04 38       	movsd  %xmm0,(%eax,%edi,1)
  1012da:	83 c7 08             	add    $0x8,%edi
  1012dd:	39 fe                	cmp    %edi,%esi
  1012df:	75 ef                	jne    1012d0 <memcpy+0x60>
  1012e1:	39 ce                	cmp    %ecx,%esi
  1012e3:	74 17                	je     1012fc <memcpy+0x8c>
  1012e5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  1012ec:	00 00 00 
  1012ef:	90                   	nop
  1012f0:	0f b6 1c 32          	movzbl (%edx,%esi,1),%ebx
  1012f4:	88 1c 30             	mov    %bl,(%eax,%esi,1)
  1012f7:	46                   	inc    %esi
  1012f8:	39 f1                	cmp    %esi,%ecx
  1012fa:	75 f4                	jne    1012f0 <memcpy+0x80>
  1012fc:	5e                   	pop    %esi
  1012fd:	5f                   	pop    %edi
  1012fe:	5b                   	pop    %ebx
  1012ff:	c3                   	ret    
